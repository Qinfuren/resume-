##js中基本数据类型
	* 基本(值)类型 : Number/String/Boolean/Undefined/Null
	* 对象(引用)类型 : Function/Array/Object
##数据类型的判断
	 1). typeof : 数值/字符串/布尔值/undefined/function
	 2). instanceof : array/object/function
	 3). === : null
##一切(引用类型)皆对象, 数组,函数,对象都是对象
	 * 一切皆数据, 函数也是数据
	 * 对象里面的一切都是属性(包括方法),对象是若干属性的集合
	 * 对象又都是通过函数创建的, 函数也是对象
	 * A instanceof B 判断A是不是B构造函数的实例
##回掉函数
	* 自己定义的
	* 自己没调用
	* 但是它执行了
##函数的prototype属性
     1.1). 每个函数都有一个prototype属性, 它默认指向一个对象(原型对象)
     1.2). 原型对象中有一个属性constructor, 它指向对应的函数对象
     1.3). Object的原型
         object对象的方法都定义在Object的原型对象中
         object的原型对象的原型为null(没有父对象)
	     console.log(Object.prototype.__proto__)// null

##判断是不是指定对象的属性，用hsaOwnProperty(),是Object函数原型中的一个方法
##原型中的constructor属性指向对应的构造函数（实例的构造函数，函数本身）
##显示原型与隐式原型（特例：Function.prototype === Function.__proto__成立）
* 每个函数function都有一个prototype，即显式原型
    （同时每个函数function 作为Function的实例对象，都有一个__proto__，即隐式原型）我自己添加的
     每个函数在定义时, 自动拥有了此属性, 且默认值为空object对象
* 每个实例对象都有一个__proto__，可称为隐式原型
    每个prototype中都有一个__proto__，等于对应的构造函数Object；
    在实例对象在被创建时, 自动拥有了此属性, 且其值为对应构造函数的prototype的值
	‘.’左边是引用变量，指向一个地址
    变量在左边是被赋值，在右边是读取值
    一个实例两个值，一个地址值（存储值）和内部保存的值
	读取对象本身的值:地址值，不是内部保存的值
	读取变量的值： 变量保存的值，不是地址值


##原型属性问题
    读取对象的属性值时: 会自动到原型链对象中查找
    设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值

##原型链（我们在查找对象的属性的时候要用到原型链）
    访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找
	构造函数/原型/实体对象的关系(图解)
	构造函数/原型/实体对象的关系2(图解)
	原型继承
		构造函数的实例对象自动拥有构造函数原型对象的属性(方法)
		基本原理: 原型链
##instanceof是如何判断的?
    表达式: A instanceof B
    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
	Function是通过NEW自己产生的实例对象,就这一个比较特殊

	console.log(Object instanceof Function);//true
    console.log(Object instanceof Object);//true
    console.log(Function instanceof Function);//true
    console.log(Function instanceof Object);//true
    console.log(Function.prototype === Function.__proto__);//true
    console.log(Function.prototype.__proto__ === Object.prototype);//true

##上下文环境的理解
    1. 也称执行上下文环境环境(执行代码的环境)
    2. 本质是一个对象,由js引擎自动帮我们创建, 但它对我们是透明的, 我们只能直接使用其属性
    3. js引擎在执行全局代码段会先做些"准备工作"
        1). 将Global对象(window)作为全局上下文环境对象
        2). 将一些表达式初始化赋值
            哪些变量会被初始化? 
				* 用var声明的变量，只要有var，就会被初始化,会被初始化成什么值?  undefined
				* function声明的函数， 整个函数初始化，且优先于var声明的变量
        3). 将它们设置为上下文环境对象(window)的属性
    4. js引擎在执行函数体之前也会先做些"准备工作"
        1). 创建函数上下文环境对象
	     2). 将一些变量进行初始化赋值
				* 用var声明的变量，只要有var，就会被初始化,会被初始化成什么值?  undefined
				* function声明的函数， 整个函数初始化，且优先于var声明的变量
	     3). 将它们设置为上下文环境对象的属性
     5. 变量提升与函数提升
         1). 变量提升
             通过var定义的变量, 在定义（执行）语句之前就可以访问到值: undefined
         2). 函数提升
             通过function声明的函数, 在（函数代码位置）之前就可以直接调用值: 函数定义(对象)

 
##执行上下文环境分类
    1. 全局上下文环境（只有一个，只要页面在，window就在）
        1). 初始化时间
            在全局js代码开始执行之前生成（全局上下文环境生成好时，已经完成初始化工作）
        2). 初始化工作（三项数据）
            var定义的全局变量(任意类型值)——变量声明，默认赋值为undefined
            使用function声明函数——赋值(函数定义)
            this——赋值(window)
    2. 函数上下文环境(定义了几个函数并调用了，调用n次，就有n个函数上下文环境
   函数执行完，局部变量就没有了；调用的时候产生；动态生成，适当时机释放空间)
        1). 初始化时间
            在调用函数时, 函数体执行前之前生成
        2). 初始化工作
            var定义的变量(任意类型)——变量声明，默认赋值为undefined
            函数声明——赋值(函数定义)
            this——赋值(调用函数的对象)
            形参变量----赋值(实参)
            arguments----赋值(实参列表伪数组)
##this到底是谁
	1. 本质上任何函数在执行时都是通过某个对象调用的
	2. this就代表调用函数的当前对象
	3. 在定义函数时, this还没有确定, 只有在执行时才确定
	4. 当调用函数时没有明确指定当前对象，this就是全局对象window
##上下文环境栈:
    在js代码执行过程中, JS引擎会用一个栈结构容器来管理所有创建的上下文环境对象
##作用域
    1. 就是一块"地盘", 一个代码段所在的区域, 它是静态的(相对于上下文对象)
    2. js默认就有全局作用域, 其它作用域都是函数作用域,没有块级作用域
    3. 全局作用域在一开始编写JS代码时就确定了(在写script标签的时候就有了), 不是在运行时
    4. 函数作用域是在创建函数时就确定了, 不是在运行时
    5. 作用域的作用
        最大的用处就是隔离变量，不同作用域下同名变量不会有冲突（冲突就是后面的将前面的覆盖了）
    6. 作用域之间的上下级关系
        上下级关系的确定就看函数是在哪个作用域下定义的（定义的位置）
##作用域与上下文间的区别
	1. 区别1（实行的时机不同）
	     1). 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
	     n + 1 个n :函数的个数，也就是函数作用域的个数；　　１：　全局作用域
	     2). 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
	     3). 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建（形参已经的到实参的值了）
	2. 区别2（状态不同）
	     1). 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
	     2). 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放
	3. 联系（）
	     1). 上下文环境(对象)是从属于所在的作用域
	         全局上下文环境--->全局作用域
	         函数上下文环境--->对应的函数作用域
	     2). 示意图

##作用域链
	1. 理解
         1). 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
         先在当前的环境对象中找、找到即止，否则往上找
         2). 查找变量时就是沿着作用域链来查找的
    2. 引用(查找)一个变量的查找规则
         1). 在当前作用域下的执行上下文环境中查找对应的属性, 如果有直接返回, 否则进入2
         2). 在上一级作用域的执行上下文环境中查找对应的属性, 如果有直接返回, 否则进入3
         3). 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常

##闭包
	1. 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
    	两个条件： 存在嵌套；内部函数引用了外部函数的数据
    2. 闭包到底是什么?
        使用chrome调试查看
        理解一: 闭包是嵌套的内部函数(绝大部分人)
        理解二: 包含被引用变量(函数)的对象(极少数人)
        注意: 闭包存在于嵌套的内部函数中
    3. 产生闭包的条件?
        函数嵌套
        内部函数引用了外部函数的数据(变量/函数)
##常见的闭包
	1. 将函数作用另一个函数的返回值
    2. 将函数作为实参传递给另一个函数调用
     */
    闭包的作用：
    延长了局部变量的生命周期
    孤立的对象，也就是垃圾对象
 	1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
    2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
##闭包的生命周期
	1. 产生: 在嵌套内部函数定义执行完(预处理执行/隐式执行)时就产生了(不是在调用)
    2. 死亡: 在嵌套函数成为垃圾对象时（）
     内部函数不调用可以，但外部调用不可以；

##闭包的应用
	闭包的应用1 : 回调函数
	闭包的应用2 : 模块化
     模块化: 将一些数据和数据操作封装起, 供外部调用
     一个js文件就是一个模块；
##闭包的缺点
	1.缺点	
	     函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
	     容易造成内存泄露/损失（后面不用了，当时局部变量还占用内存，不报错，运行卡）
	     内存溢出，出错，（给你的空间小于你需要的空间）
	2. 解决
	     能不用闭包就不用
	     及时释放
##对象的创建方式
	1.Object构造函数模式
         创建一个对象
         问题: 语句太多
	2.使用对象字面量创建一个对象
         创建一个对象
         问题(缺点): 如果创建多个对象, 有重复代码
	3.工厂模式
         问题：对象没有一个具体的类型, 只是Object
	4.自定义构造函数模式
         问题: 必须通过new调用
	function Person(name, age){
        if(this instanceof Person){//判断this是不是Person的实例对象
            this.name =  name;
            this.age = age;
            this.setName = function (name){
                this.name = name;
            }
        }else{
            return new Person(name, age)
        }
    }
    var person1 = Person('Tom', 100);
    var person2 = new Person('Alice', 120);
    console.log(person1);
    console.log(person2);
	5.原型模式
	function Person(){}
    Person.prototype.name = 'Jack';
    Person.prototype.age = 32;
    Person.prototype.setName = function (name){
        this.name = name;//给this添加name属性
    };
    var p = new Person();
    console.log(p);
    console.log(p);
    p.setName('AAAA');
	6.构造函数+原型组合模式
	7.动态原型模式
	function Person(name, age){//将属性定义在构造函数中
        this.name = name;
        this.age = age;
        if(!this.setName){//如果没有setName属性，
            Person.prototype.setName = function(name){//将方法定义在显示原型中
                this.name = name;
            }
        }
    }
    var p1 = new Person('Tom');
    console.log(p1);
    p1.setName('Alice');
    console.log(p1);
##new 创建对象的过程:
     1.创建一个空对象（{}） 局部作用域
     2.给它添加一个__proto__属性，其值为构造函数的prototype属性值
     3.将this指定为当前创建的空对象，执行构造函数体语句

##继承方式
	1.原型链继承
        不足： 无法获得动态属性
        优势： 能够从父元素那里继承方法
        实例对象从其对应的构造函数继承各种属性（方法）
	2.在子类型构造函数内部调用超类型的构造函数
         有点： 能够从父类型中得到动态属性
         缺点：得不到父类型中原型中的方法
	3.组合继承
	 使用原型链实现对原型对象属性和方法的继承，使用构造函数实现对实例对象属性的继承
     组合继承是很常用的继承方式
	 缺点:就是需要调用两次超类型的构造函数。

##线程与进程
	js代码是单线程的
    进程：程序的一次执行, 它占有一片独有的内存空间(每打开一个页面，就开启一个进程，chrom 、IE)多个实例
    线程： CPU的基本调度单位, 是程序执行的一个完整流程(计算机多核，可以同时运行多个线程)并行同一个时刻，并发同一个时间段
    一个进程中一般至少有一个运行的线程: 主线程（启动时变创建好了）
    一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
    一个进程内的数据可以供其中的多个线程直接共享
    多个进程之间的数据是不能直接共享的
     线程池，可以重复利用，最小的线程个数，实现最多的功能
     浏览器运行是单进程还是多进程?
         有的是单进程
             firefox
             老版IE
         有的是多进程
             chrome
             新版IE
         如何查看浏览器是否是多进程运行的呢?
            任务管理器-->进程
     浏览器运行是单线程还是多线程?
        都是多线程运行的
##同步与异步
 	同步与异步:
         它们描述的是调用执行功能程序的方式（假设这个程序执行的时间比较长）
         同步: 就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回(绝大多数是同步调用)
         异步: 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果, 但会立即返回.
              实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者
    同步与异步的例子:
        同步:
            打电话: 你说完了, 我说
            你想喝咖啡，就要先烧开水，然后泡咖啡
            普通B/S请求: 提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事
        异步:
            发消息 : 我只管发消息, 但你收不收得到,回不回我不管
            你在等烧开水的时候可以在旁边看报纸
            AJAX模式请求: 通过事件触发请求->服务器处理（这时浏览器仍然可以作其他事情）->处理完毕
            open中的第三个参数确定同步、异步，影响的是send
            发送10个请求，可以瞬间发出去

##浏览器内核
	支持浏览器运行的最核心的程序
    不同的浏览器可能不太一样
         Chrome, Safari : webkit
         firefox : Gecko
         IE	: Trident
         360,搜狗等国内浏览器: Trident + webkit
    内核由很多模块组成
         js引擎模块 : 负责js程序的编译与运行
         定时器模块 : 负责定时器的管理
         DOM/CSS模块 : 负责dom/css在内存中的相关处理
         网络请求模块 : 负责服务器请求(常规/Ajax)
         事件响应模块 : 负责事件的管理
         html,css文档解析模块 : 负责页面文本的解析
         布局和渲染模块 : 负责页面的布局和效果的绘制
##定时器
	 1. 定时器真是定时执行的吗?
         1). 定时器并不能保证真正定时执行
         2). 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)
     2. 定时器回调函数是在分线程执行的吗?
        在主线程执行的, js是单线程的
     3. 定时器是如何实现的?
        事件循环模型(后面讲)
##js是单线程的
	1. 如何证明js执行是单线程的?
	    setTimeout()的回调函数是在主线程执行的
	    定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
	2. 为什么js要用单线程模式, 而不用多线程模式?
	    JavaScript的单线程，与它的用途有关。
	    作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。（响应用户操作）
	    这决定了它只能是单线程，否则会带来很复杂的同步问题
	    只能有主线程更新页面
##事件循环模型
	1. 事件都有对应模块来管理
    2. 当我设置一个事件监听时: 将事件回调函数交给对应模块管理
    3. 模块会在对应的条件或时刻将事件回调函数加入回调队列(这个操作是准时的)
    4. 只有当运行栈全部执行完后(可能要一定的时间才能完成, 导致回调函数延后执行了), 才会遍历读取回调队列中的回调函数执行
##H5提供了js多线程运行API
	相关API:
        Worker : 用于加载分线程执行的js的类

	//主线程执行时无法操作界面
    //创建worker对象
    var worker = new Worker('worker.js');
    console.log(01);
    worker.onmessage = function(event){

        var result =event.data;
    }

    worker.postMessage('I like you')
    console.log(10);
##数据结构
* 真是结构
	* 在内存中真实存在的, 用来存放多个数据的内存结构
	* 数组
		* 申请内存
			* 一次申请一大段连续的空间，一旦申请到，内存就固定了
		* 存储思路
		* 操作
			* 读内存
				* 查：每个元素都有一个数值下标, 可以通过下标瞬间定位到某个元素
				* 增：插入元素，引起部分元素后移，代价非常高
			* 写内存
				* 删：去掉元素，引起部分元素前移，代价非常高
				* 改：只需要修改对应位置的元素的内容，不需要申请或者删除空间
		* 特点
			* 查询效率非常高
			* 数组查找快, 但添加/删除效率低
		* 适用范围
			* 查询操作远多于插入删除操作的场景

	* 链表
		* 申请内存
			* 一次申请一小块内存，按需申请
		* 存储思路
		* 操作
			* 读数据
				* 查：节点是没有下标的, 只能从链表的表头开始查找某个节点
			* 写数据
				* 增：申请一小块内存--结点
				* 删：从链中剥离结点；释放这个结点的内存
				* 改：改变这个结点中所存储的值
		* 特点
			* 查找速度慢
			* 添加删除快
		* 适用范围
			* 插入删除操作远多于查询操作的场景
			* 复杂抽象数据结构的基石
* 抽象结构
	* 在内存中并不存在此结构, 由程序员利用数组/链表封装成的结构
	* 栈（Stack）
		* 特点：后进先出
		* 行为：
			* 进栈：push(element)
			* 查看栈顶元素：peek()
			* 出栈：pop()
			* 请栈：clear()
			* 大小：size()
			* 判断是否为空：isEmpty()
		* 适用场景
			* 运行栈
	* 队列（Quene）
		* 特点：先进先出
		* 行为：
			* 添加：enqueue(element)
			* 读取：first()
			* 移除：dequeue()
			* 清楚队列：clear()
			* 大小：size()
			* 判断是否为空：isEmpty()
		* 应用场景：
			* 事件队列，消息队列
	* 二叉树
		* 计算机世界的树

##算法
* 二分法
* 排序
	* 简单排序
		* 冒泡排序

	function bubbleSort(arr){
		var alt = arr.length;
		for(var i=0;i<alt;i++){
			for(var j=alt-1;j>i;j--){
				fn(arr,j-1;j-2)
			}
		}
		function fn(arr,index1,index2){
			if(arr[index1]<arr[index2]){
				var temp = arr[index1]
				arr[index1] = arr[index2]
				arr[index2] = temp;
			}
		}
	}
		* 选择~
		* 插入~
	* 复杂排序
		* 快速~
			* 算法步骤：
			1. 从数列中挑出一个元素，称为 “基准”（pivot），
			2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
			3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
				- 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
		* 希尔~
		* 归并~
		* 堆~

